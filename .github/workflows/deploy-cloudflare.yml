name: Deploy to Cloudflare Pages and Deno Deploy

on:
  push:
    branches: [main, master]
    paths:
      - 'app/**'
      - 'public/**'
      - 'functions/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'deno.json'
      - 'vite.config.ts'
      - 'tsconfig.json'
      - 'tailwind.config.*'
      - '.github/workflows/deploy-cloudflare.yml'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  deployments: write
  pull-requests: write

jobs:
  deploy-deno:
    runs-on: ubuntu-latest
    name: Deploy to Deno Deploy
    outputs:
      url: ${{ steps.deno-deploy.outputs.url }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v2.x

      - name: Check Deno version
        run: |
          echo "üìã Deno version information:"
          deno --version

      - name: Verify Deno functions
        run: |
          echo "üîç Checking Deno functions..."
          deno check functions/*.ts
          echo "‚úÖ All functions type-checked successfully"

      - name: Test Deno functions
        run: |
          echo "üß™ Testing function imports..."
          deno run --allow-net --allow-env --allow-read functions/router.ts &
          SERVER_PID=$!
          sleep 3

          # Test if server is responding
          if curl -f http://localhost:8000/ > /dev/null 2>&1; then
            echo "‚úÖ Router is responding correctly"
          else
            echo "‚ùå Router test failed"
            exit 1
          fi

          # Clean up
          kill $SERVER_PID || true
          wait $SERVER_PID 2>/dev/null || true

      - name: Deploy to Deno Deploy
        id: deno-deploy
        uses: denoland/deployctl@v1
        with:
          project: ${{ secrets.DENO_DEPLOY_PROJECT }}
          entrypoint: functions/router.ts
          root: .
        env:
          DENO_DEPLOY_TOKEN: ${{ secrets.DENO_DEPLOY_TOKEN }}
        continue-on-error: true

      - name: Log Deno Deploy Status
        run: |
          if [ -z "${{ secrets.DENO_DEPLOY_PROJECT }}" ] || [ -z "${{ secrets.DENO_DEPLOY_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Deno Deploy secrets not configured - skipped deployment"
            echo "üìù To enable Deno Deploy, set DENO_DEPLOY_PROJECT and DENO_DEPLOY_TOKEN secrets"
          else
            echo "‚úÖ Deno Deploy attempted with project: ${{ secrets.DENO_DEPLOY_PROJECT }}"
          fi

  deploy-cloudflare:
    runs-on: ubuntu-latest
    name: Deploy to Cloudflare Pages
    needs: deploy-deno
    outputs:
      url: ${{ steps.cloudflare-deploy.outputs.url }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Remix SPA
        env:
          VITE_API_BASE_URL: ${{ needs.deploy-deno.outputs.url }}
        run: pnpm build

      - name: Ensure SPA fallback (_redirects)
        run: |
          if [ -f public/_redirects ]; then
            mkdir -p build/client
            cp public/_redirects build/client/_redirects
          fi

      - name: Compute Cloudflare project slug
        run: |
          BASE_NAME="${{ github.event.repository.name }}"
          # lowercase, replace non [a-z0-9-] with '-', trim leading/trailing '-', and cap length to 63
          SLUG=$(echo "$BASE_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g' | sed -E 's/^-+|-+$//g' | cut -c1-63)
          if [ -z "$SLUG" ]; then
            SLUG="site-${GITHUB_RUN_ID}"
          fi
          echo "Using Cloudflare project: $SLUG"
          echo "PROJECT_SLUG=$SLUG" >> "$GITHUB_ENV"

      - name: Ensure Cloudflare Pages project exists (wrangler)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CI: true
        run: |
          set -e
          echo "Wrangler version:"; pnpm dlx wrangler --version
          test -n "$CLOUDFLARE_ACCOUNT_ID" || { echo "CLOUDFLARE_ACCOUNT_ID is empty"; exit 1; }
          test -n "$CLOUDFLARE_API_TOKEN" || { echo "CLOUDFLARE_API_TOKEN is empty"; exit 1; }

          echo "Checking for existing project: ${PROJECT_SLUG}"
          if pnpm dlx wrangler pages project info "$PROJECT_SLUG" >/dev/null 2>&1; then
            echo "Project '${PROJECT_SLUG}' already exists"
          else
            echo "Creating project '${PROJECT_SLUG}'..."
            CREATE_OUT=$(pnpm dlx wrangler pages project create "$PROJECT_SLUG" --production-branch=main 2>&1) || true
            echo "$CREATE_OUT"
            if echo "$CREATE_OUT" | grep -qi "already exists"; then
              echo "Project already exists (race), continuing"
            elif echo "$CREATE_OUT" | grep -qiE "Successfully created|created the"; then
              echo "Project created"
            else
              echo "Failed to ensure project creation. Check API token permissions (Account: Cloudflare Pages: Read, Edit) and Account ID."; exit 1
            fi
            echo "Verifying creation (with retries)..."
            VERIFIED=0
            for i in 1 2 3 4 5; do
              if pnpm dlx wrangler pages project info "$PROJECT_SLUG" >/dev/null 2>&1; then
                echo "Verified on attempt $i"
                VERIFIED=1
                break
              fi
              echo "Attempt $i failed, retrying in 2s..."; sleep 2
            done
            if [ "$VERIFIED" -ne 1 ]; then
              echo "Warning: Could not verify project via wrangler info. Continuing; deploy step will surface any issues."
            fi
          fi

      - name: Deploy to Cloudflare Pages (wrangler v3 deploy)
        id: cloudflare-deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          set -e
          echo "Wrangler version:"; pnpm dlx wrangler --version
          echo "Deploying project '${PROJECT_SLUG}' from directory 'build/client'"
          DEPLOY_OUT=$(pnpm dlx wrangler pages deploy build/client --project-name "${PROJECT_SLUG}" 2>&1) || {
            echo "$DEPLOY_OUT"
            exit 1
          }
          echo "$DEPLOY_OUT"
          # Extract first pages.dev URL from output
          URL=$(echo "$DEPLOY_OUT" | grep -Eo 'https?://[^ ]+\.pages\.dev[^ ]*' | head -n1)
          if [ -n "$URL" ]; then
            echo "url=$URL" >> "$GITHUB_OUTPUT"
            echo "Deployment URL: $URL"
          else
            echo "Warning: No deployment URL found in wrangler output" >&2
          fi

      - name: Update Repository Homepage URL
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const deploymentUrl = '${{ steps.cloudflare-deploy.outputs.url }}';
            
            if (deploymentUrl && deploymentUrl !== '') {
              try {
                await github.rest.repos.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  homepage: deploymentUrl,
                  description: 'Remix SPA ‚Äì Cloudflare Pages static deployment'
                });
                
                console.log(`‚úÖ Repository homepage updated to: ${deploymentUrl}`);
              } catch (error) {
                console.error('‚ùå Failed to update repository homepage:', error);
                core.setFailed(`Failed to update homepage: ${error.message}`);
              }
            } else {
              console.log('‚ö†Ô∏è No deployment URL found, skipping homepage update');
            }

      - name: Create GitHub deployment
        if: always()
        id: create-deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Cloudflare Pages deployment',
              auto_merge: false,
              required_contexts: []
            });
            
            return deployment.data.id;

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const deploymentUrl = '${{ steps.cloudflare-deploy.outputs.url }}';
            const state = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            const deploymentId = ${{ steps.create-deployment.outputs.result }};
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: state,
              environment_url: deploymentUrl || '',
              description: state === 'success' ? 'Deployment succeeded' : 'Deployment failed'
            });

      - name: Comment on PR with deployment URLs
        if: github.event_name == 'pull_request' && success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const denoUrl = '${{ needs.deploy-deno.outputs.url }}';
            const cloudflareUrl = '${{ steps.cloudflare-deploy.outputs.url }}';

            let comment = 'üöÄ **Deployment Complete**\n\n';

            if (cloudflareUrl && cloudflareUrl !== '') {
              comment += `‚úÖ **Cloudflare Pages**: ${cloudflareUrl}\n`;
            }

            if (denoUrl && denoUrl !== '') {
              comment += `‚úÖ **Deno Deploy Functions**: ${denoUrl}\n`;
            }

            comment += '\nüìù Your full-stack application is now live!';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
